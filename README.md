# 主要针对下次面试C++相关的准备

###1. 有哪几种情况只能用intialization list 而不能用assignment?
答案：当类中含有const、reference 成员变量；基类的构造函数都需要初始化表。

###2. 请说出const与#define 相比，有何优点？
const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。

1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。

2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。

###3.简述数组与指针的区别？
数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。
1）修改内容上的差别：
char str[] = "hello world!";
str[0] = 'H';

char* p = "hello weold!"; //注意p 指向常量字符串
//p[0] = 'H'; 非法，编译通过，运行出错

2）用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。
```
cout<<str<<" size:"<<sizeof(str)<<endl; //13字节
dumpArrSize(str);
cout<<p<<" size:"<<sizeof(p)<<endl;//8字节
dumpArrSize(p);
void dumpArrSize(char*p){
    cout<<"p int func size: "<<sizeof(p)<<endl;//8字节
}
```

###4.引用与指针有什么区别？
1) 引用必须被初始化，指针不必。

2) 引用初始化以后不能被改变，指针可以改变所指的对象。

3) 不存在指向空值的引用，但是存在指向空值的指针。

###5. 值传递、指针传递、引用传递详解
####值传递：
形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参->形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。

####指针传递：
指针参数传递本质上是值传递，它所传递的是一个 **地址值**。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，**会在栈中开辟内存空间以存放由主调函数传递进来的实参值**，从而形成了实参的一个副本（替身）。值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。但是改变了形参指针指向的地址上的内容。那么实参指针指向的内容也会发生变化。

####引用传递：
形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形参虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。
>值传递不会影响实参的值。指针传递和引用传递会影响实参的值

总结：
相同点：
　　都是地址的概念

不同点：
　　指针是一个实体（替身）；引用只是一个别名（本体的另一个名字）

　　引用只能在定义时被初始化一次，之后不可改变，即“从一而终”；指针可以修改，即“见异思迁”；

　　引用不能为空（有本体，才有别名）；指针可以为空；

　　sizeof 引用，得到的是所指向变量的大小；sizeof 指针，得到的是指针的大小；

　　指针 ++，是指指针的地址自增；引用++是指所指变量自增；

　　引用是类型安全的，引用过程会进行类型检查；指针不会进行安全检查；
参考代码：
```
#include <iostream>
using namespace std;
//改变指针指向的内容
void change_1(int * a){
    *a = *a+1;
}

//改变形参指针的值，使指向的地址改变，不会影响到实参，就是值传递
void change_2(int * a ){
    int b = 10;
    a=&b;
    cout<<"in func change_2 n: "<<*a<<endl;//10
}

void change_3(int &a){
    a = a+1;
}

int main(int argc, const char * argv[]) {
#pragma 指针传递和引用传递
    int n = 100;
    change_1(&n);
    std::cout<<"change_1 n: "<<n<<std::endl;//101
    change_2(&n);
    std::cout<<"change_2 n: "<<n<<std::endl;//101
    change_3(n);
    std::cout<<"change_3 n: "<<n<<std::endl;//102
    return 0;
}
```

####引用和指针作为函数的返回值
1）指针作为函数的返回值
```
//返回局部变量的指针允许，pstr指向的是常量存储区
char* test_1(){
    char *pstr = "This is the buffer text";
    return pstr;
}
//允许pstr指向的是静态存储区
char* test_3(){
    static char pstr[] = "This is the buffer text";
    return pstr;
}
//不允许pstr指向的是栈上的内存
char* test_2(){
    char pstr[] = "This is the buffer text";
    return pstr;
}
```

2)引用作为函数的返回值

优点：
在内存中不产生返回值的副本（返回一个局部变量的引用是不可取的，因为随着局部变量生存周期的结束，相应的引用也会失效，产生runtime error）

注意：
不能返回局部变量的引用，局部变量会在函数返回后被销毁。

不能返回函数内部new分配的内存的引用，虽然不存在局部变量的被动销毁问题，但是函数返回的引用只是作
为一个临时变量出现，并没有被赋予一个实际的变量，导致引用所指向的空间无法释放。

可以返回类成员的引用，但最好是const，主要原因是当对象的属性与某种业务规则相关联的时候，其赋值常常与某些其它属性或者对象的状态相关联，因此有必要将赋值操作封装在一个业务规则中，如果其它对象可以获得该属性的非常量引用（或指针），那么对于该属性的单纯赋值就会破坏业务规则的完整性。

流操作符重载返回值申明为“引用”的作用：<<和>>常常希望被连续使用，因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选方案包括：返回一个流对象和返回一个流对象指针。返回一个流对象，程序必须重新构造一个新的流对象，两个<<操作符实际上是针对了不同对象；返回一个流对象指针，并不能连续使用<<操作符。返回一个流对象引用则是唯一选择。

####lambda表达式基本用法
#####1）声明Lambda表达式
Lambda表达式完整的声明格式如下：
>[capture list] (params list) mutable exception-> return type { function body }

各项具体含义如下
>* capture list：捕获外部变量列表
>* params list：形参列表
>* mutable指示符：用来说用是否可以修改捕获的变量
>* exception：异常设定
>* return type：返回类型
>* function body：函数体

#####2)具体用法
```
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main()
{
    vector<int> myvec{ 3, 2, 5, 7, 3, 2 };
    sort(myvec.begin(), myvec.end(), [](int a, int b) -> bool { return a < b; });   // Lambda表达式
    cout << "lambda expression:" << endl;
    for (int it : myvec)
        cout << it << ' ';
}
```

#####3)捕获外部变量
[]：默认不捕获任何变量；
[=]：默认以值捕获所有变量；
[&]：默认以引用捕获所有变量；
[x]：仅以值捕获x，其它变量不捕获；
[&x]：仅以引用捕获x，其它变量不捕获；
[=, &x]：默认以值捕获所有变量，但是x是例外，通过引用捕获；
[&, x]：默认以引用捕获所有变量，但是x是例外，通过值捕获；
[this]：通过引用捕获当前对象（其实是复制指针）；
[*this]：通过传值方式捕获当前对象；

####vector的基本用法
>vector内存空间连续， list内存空间不连续

1）vector是表示可变大小数组的序列容器
2）就像数组一样，vector也采用的连续存储空间来存储元素。也就是意味着可以采用下标对vector的元素进行访问，和数组一样高效。但是又不像数组，它的大小是可以 **动态改变**的，而且它的大小会被容器自动处理。
3）本质讲，vector使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小为了增加存储空间。其做法是，**分配一个新的数组，然后将全部元素移到这个数组**。就时间而言，这是一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大小。
4）与其它动态序列容器相比（deques, lists and forward_lists）， **vector在访问元素的时候更加高效，在末尾添加和删除元素相对高效**。对于其它不在末尾的删除和插入操作，效率更低。比起lists和forward_lists统一的迭代器和引用更好。
5) 如果元素是对象或者结构，在插入、删除元素的时候，会调用构造函数和析构函数。所以尽量存放指针。

####List基本用法
1)list就是双向链表,元素也是在堆中存放,每个元素都是放在一块内存中,它的内存空间可以是不连续的
2）list没有空间预留习惯,所以每分配一个元素都会从内存中分配,每删除一个元素都会释放它占用的内存.
























